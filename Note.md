# Navigation Mesh

## 基础介绍

https://www.youtube.com/watch?v=U5MTIh_KyBc&list=PLokhY9fbx05eeUZCNUbelL-b0TyVizPjt&index=6

导航网格是一种数据结构，过将表面或空间编码为一系列多边形，来表示表面或空间的可访问性。
![](image/2021-05-04-15-16-01.png)
![](image/2021-05-04-15-16-30.png)

游戏中AI在给定的表面上移动，很可能是使用了导航网格。

**导航网格存储着一些关于AI如何在空间中移动的重要数据，例如：
1、哪些表面是可以访问的。
2、各个表面是如何与其他表面链接的。
3、将这些表面划分为特定的类型或区域，穿越不同区域会有不同的成本，也可以告诉AI它们现在正处于什么类型的区域。**

对空间的可访问性进行建模对于实现任何类型的智能运动都是至关重要的，**因为这种易于计算的方式可以让我们确保我们的角色知道它是否可以在游戏空间中移动。**

**同时区域的类型很重要，可以让AI看起来更聪明一些**。例如在刺客信条和孤岛惊魂中，AI会极力避免中水中移动，而选择在海岸旁边进行攻击或到处走动。利用成本来控制区域。可以让AI优先做出更符合我们预期的移动，比如GTA中的平民，AI可以沿着人行道走，会使用红绿灯。

链接可以帮助我们管理角色如何穿越导航网格中的间隙。通常我们希望当AI在特定的地点时，会在导航网格之间移动，例如：在《极度恐慌》中，士兵会在楼梯爬上爬下，在DOOM中恶魔会跳上更高的台阶。**链接决定了在何处以及何时发生这些情况，它们通常与动画紧密联系，这些动画在遍历链接时会播放。**

当导航网格出问题时，通常也是最容易被看出来的。


一些早期技术，如：meadow mapping 或 [voronoi tessellation](https://zh.wikipedia.org/wiki/%E6%B2%83%E7%BD%97%E8%AF%BA%E4%BC%8A%E5%9B%BE)
,可以将空间分割成多个多边形，
![](image/2021-05-04-16-10-07.png)
这是构建导航网格的基石。

空间被分解后，AI就可以使用搜索算法来绘制可以穿过空间的路径，并将路径优化得更加自然。
![](image/2021-05-04-16-12-30.png)


导航网格通常是在开发过程中预先在引擎中烘培的，作为数据存储在关卡文件中。


# Behaviour Trees

 https://www.youtube.com/watch?v=6VBCXvfNlCM&list=PLokhY9fbx05eeUZCNUbelL-b0TyVizPjt&index=5

## 基础知识
 行为树是一棵多叉树，我们在其中设置规则，包括某些行为怎么发生和它们执行的顺序。如何选择行为基于如何向下移动到子节点中。

 **行为树通常有4种节点**：

 1. 根节点，这是行为的开始。
 2. 叶子节点，这是实际放置AI行为的地方，例如移动到世界中的某个位置，向敌人开枪。

 3. 选择器，根据某些逻辑决定要执行哪个子节点。例如：如果距离玩家太远，它将不会近战攻击的子节点，但它可能执行远程攻击的子节点。
 4. 序列节点，这使我们可以依次执行多个子节点，

 最后还有装饰器节点，它们采用子节点现有的逻辑并执行操作。这非常合适用来做重复动作，或让选择器做出相反的决定。

## 工作原理

 传统上构建行为树时，想法是每一帧，游戏系统会从根节点运行一个叫“Tick”的更新，系统再遍历行为树，找到活动的节点，然后重新检查是否有其他子节点可以被激活。
 
 当树变大时，这种做法的代价比较昂贵。**所以现在行为树会保留活动的节点的引用，并处理“Tick”。一旦在该节点执行完了行为，树会重新评估该怎么做。**

 《光环》提出的一个概念就是：**使它们更受事件驱动。** 这意味着：基于游戏世界中发生的事情，行为树可以快速地切换出给定地节点，并重新评估该执行哪个节点。

 现在，**最重要的是一个称为“黑板”的组件**。黑板用来存储一些有用的数据，行为树利用这些数据来作为多重行为节点的一部分。
![](image/2021-05-05-10-30-53.png)
 例如目标位置、到最近感兴趣的物体的距离、甚至是状态变量：角色是否受到攻击、是否已经执行了特定的行为。

**利用黑板存储数据，不仅可以最大程度地减少对信息地重复计算，还可以多个行为树使用同一张黑板**，这让使用不同行为树的AI们可以轻易地共享信息，例如玩家所在的位置。

## 为什么要使用行为树

**1. 简化逻辑。**

用户可以看到决策以自上而下的方式进行，这使得系统更具拓展性。这种视觉可读性非常重要。相反，有限状态机的可读性会随着自身变复杂而降低，越复杂，状态间的连接越多。

**2.对设计师友好**

通过简化逻辑，它们对设计师更友好，而且更容易debug。简化流程，模块化行为和通过黑板分享信息减少了出错的可能性。

相比之下，有限状态机通常需要大量的代码，因为它们的执行条件通常与行为相关联。同时，现代行为树系统可以更好地支持工作流程，使设计人员可以使用已经被程序员构建好的模块来快速构建新的行为，然后针对可能缺少的某些特定行为进行研究。

**3.可重用性**

我们通常在行为树中建立个人行为，以便在不同的上下文环境中使用。树的逻辑将允许我们在需要时，重用同一个节点。

相反，有限状态机中，很多状态通常与特定的上下文环境有关。

**4.优化**

影响游戏中的每个AI系统的重大问题：CPU和内存。

“Tick”处理和事件驱动的优化会使行为树随着时间推移变得更加优化。而有限状态机仍然需要每帧更新，以确保检测到正确的状态并进行相应的转换。

最后使用黑板也允许跨节点共享数据，有助于将内存降到最低。


**行为树不是制作游戏行为的唯一选择，如果行为逻辑规模较小，有限状态机足以满足需求**










 






